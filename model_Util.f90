! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! Auxiliary Routines File
! 
! Generated by KPP-2.2.4_gc symbolic chemistry Kinetics PreProcessor
!       (http://www.cs.vt.edu/~asandu/Software/KPP)
! KPP is distributed under GPL, the general public licence
!       (http://www.gnu.org/copyleft/gpl.html)
! (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
! (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech
!     With important contributions from:
!        M. Damian, Villanova University, USA
!        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany
! 
! File                 : model_Util.f90
! Time                 : Thu Feb 16 17:13:45 2017
! Working directory    : /work/home/dp626/DSMACC-testing
! Equation file        : model.kpp
! Output root filename : model
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



MODULE model_Util

  USE model_Parameters
  IMPLICIT NONE

CONTAINS



! User INLINED Utility Functions


SUBROUTINE InitVal (concs)

USE model_Global
use model_Monitor
INTEGER :: i,j,found
REAL(kind=dp) :: x
CHARACTER(LEN=10000) :: line
CHARACTER(LEN=15) :: test
REAL(kind=dp) :: concs(NSPEC)
REAL(kind=dp) :: oldvar(NSPEC)
INTEGER :: COUNT_NOX_CONSTRAINTS, i_CH4, i_H2 , i_EMISS
CHARACTER(len=6), dimension(8) :: NOXARRAY
NOXARRAY(:)= (/'NO2   ','NO    ','NO3   ','HONO  ','HNO2  ',&
    'HO2NO2','HNO4  ','PNA   '/)
    OLDVAR(1:NVAR)=C(1:NVAR)
    VAR(1:NVAR)=0.
    C(1:NVAR)=0.
    i_EMISS=0  
    DEPOS = 0.
    SAREA=0.
    ALBEDO=0.
    RP1=0.
    
    do I=1,NSPEC+1
    FOUND=0
    if (SPEC_NAME(I) .NE. '') then
    SPEC_NAME(I)=ADJUSTL(SPEC_NAME(I))

    do J=1,NVAR 

        if (TRIM(SPEC_NAME(I)) .EQ. TRIM(SPC_NAMES(J))) then 
        FOUND=1
        VAR(J)=CONCS(I)

        if (const_method(i) > 0) then 
             CONSTRAIN(J)=CONCS(I)
             print*, 'soft-constrained ', spec_name(i), 'at', constrain(j) 
        end if
             
        if (SPEC_NAME(I) .EQ. 'CH4') then 
        SPEC_CH4=.TRUE.
        i_CH4 = I

        else if (SPEC_NAME(I) .EQ. 'H2') then
        SPEC_H2=.TRUE.
        i_H2 = I 
        end if            

        endif

    enddo
    



    if (FOUND .ne. 1) then 

    SELECT CASE (TRIM(SPEC_NAME(I)))
   
    CASE('H2O') 
    H2O=CONCS(I)

    CASE('PRESS')  
    PRESS=CONCS(I)

    CASE('NOx') 
        if (concs(i)>0) then 
        CONSTRAIN_NOX=.TRUE.
        WRITE (OUTPUT_UNIT,*) 'Constraining total NOx concentation'
        end if 

    CASE('LAT') 
    LAT=CONCS(I)

    CASE('LON')  
    LON=CONCS(I)

    CASE('TEMP') 
    TEMP=CONCS(I)

    CASE('JDAY')  
    JDAY=CONCS(I)

    CASE('TIME(GMTs)')  
    continue

    CASE('O3COL') 
    O3COL=CONCS(I)

    CASE('ALBEDO')  
    ALBEDO=CONCS(I)

    CASE('SAREA')  
    SAREA=CONCS(I)

    CASE('RP1')  
    RP1=CONCS(I)

    CASE('JNO2') 
        if (CONST_METHOD(I) .GE. 1) JNO2=CONCS(I)

        JREPEAT=0

        if (CONST_METHOD(I) .EQ. 2) JREPEAT=1


    CASE('JO1D') 

        if (CONST_METHOD(I) .GE. 1) JO1D=CONCS(I)

        JREPEAT=0

        if (CONST_METHOD(I) .EQ. 2) JREPEAT=1


    CASE('DEPOS') 

        if (CONCS(I) > 0) then  
            DEPOS = 1.
            print *, 'DEPOSITON ENABLED'
        end if 


    CASE DEFAULT
    !! for any species in the fixed array 
    if (SPEC_NAME(I)(1:1) .EQ. 'F')  then   
        SPEC_NAME(i)  = SPEC_NAME(i)(2:)

        do J=NVAR+1,NVAR+NFIX    
         
            if (TRIM(SPEC_NAME(I)) .EQ. TRIM(SPC_NAMES(J))) then 
                FOUND=1
                FIX(J-NVAR)=CONCS(I)
                print*, 'hard-constrained ', spec_name(i), ' at ', concs(I)
                    
                if (SPEC_NAME(I) .EQ. 'EMISS') then
                    i_EMISS = (J-NVAR)        
                else if (SPEC_NAME(I) .EQ. 'CH4') then 
                    SPEC_CH4=.TRUE.
                    i_CH4 = I
                else if (SPEC_NAME(I) .EQ. 'H2') then
                    SPEC_H2=.TRUE.
                    i_H2 = I               
                end if            
            else 
                    WRITE(OUTPUT_UNIT,*) SPEC_NAME(I),' NOT FOUND - stopping'
                    WRITE(6,*) SPEC_NAME(I),' NOT FOUND - stopping'
                    stop 
            endif
            
        enddo
    
    else if (SPEC_NAME(I)(1:1) .NE. 'X') then 
        WRITE(OUTPUT_UNIT,*) SPEC_NAME(I),' NOT FOUND - stopping'
        WRITE(6,*) SPEC_NAME(I),' NOT FOUND - stopping '
        stop   
        end if 
        WRITE (OUTPUT_UNIT,*) 'Starts with X => ignored'   
 
    
    END SELECT
    endif
    endif


    enddo

    !convert to mol cm-3s-1
    CFACTOR=PRESS*1e2*1e-6/(8.314*TEMP)*6.022E23
    H2O=H2O*CFACTOR 
    VAR(:)=VAR(:)*CFACTOR
    CONSTRAIN(:)=CONSTRAIN(:)*CFACTOR
    FIX(:)=FIX(:)*CFACTOR
    if (i_EMISS>0) FIX(i_EMISS)= FIX(i_EMISS)/CFACTOR 
    !correct emissions ^^

    
    if (CONSTRAIN_NOX) then 
        COUNT_NOX_CONSTRAINTS=0


        do I=1,NVAR 
        do j= 1,8 

        if (TRIM(SPC_NAMES(I)) .EQ. TRIM(NOXARRAY(j))) then 
        NOX(I)=1
        CONSTRAIN(I)=-1.*CONSTRAIN(I)
        if (CONSTRAIN(I) .NE. 0 .and.&  
            TRIM(SPC_NAMES(I)).ne. 'PNA')& 
            COUNT_NOX_CONSTRAINTS=COUNT_NOX_CONSTRAINTS+1
            WRITE (OUTPUT_UNIT,*) SPC_NAMES(I),' IN NOX FAMILY'
            exit
            end if
            end do 

            if (TRIM(SPC_NAMES(I)) .EQ. 'N2O5') then
            NOX(I)=2
            CONSTRAIN(I)=-1.*CONSTRAIN(I)
            if (CONSTRAIN(I) .NE. 0)  COUNT_NOX_CONSTRAINTS=&
            COUNT_NOX_CONSTRAINTS+1
            endif

            end do

            if (COUNT_NOX_CONSTRAINTS .GT. 1) then 
            WRITE (OUTPUT_UNIT,*) 'You can not contrain multiple NOX species'
            STOP
            endif

    end if


        ! FIND CH4 and H2 species
        if (SPEC_CH4 .EQv. .FALSE. .and. i_CH4 .ne. 0) then
        WRITE (OUTPUT_UNIT,*) 'No CH4 specified assuming 1770 ppbv'
        VAR(i_CH4)=1770e-9*CFACTOR
        CONSTRAIN(i_CH4)=VAR(i_CH4)
        end if

        if (SPEC_H2 .EQv. .FALSE. .and. i_H2 .ne. 0) then 
        WRITE (OUTPUT_UNIT,*) 'No H2 specified assuming 550 ppbv'
        VAR(i_H2)= 550e-9*CFACTOR
        CONSTRAIN(i_H2)=VAR(i_H2)
        end if




        END SUBROUTINE Initval
        ! End of InitVal function
        ! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


        ! ****************************************************************
        ! ****************************************************************
        !                            
        ! SaveData - Write LOOKAT species in the data file 
        !   Parameters :  index_loc = daycounter                                J(41)
        !
        ! ****************************************************************

        subroutine SaveOut(index_loc)
        USE model_Global
        USE model_Monitor
        USE model_Integrator
        integer :: index_loc
        
        !print *, 'adjust to reflect multiple times'
        !spec
        output_s(index_loc,1)=Jday*86400  + DAYCOUNTER*dt 
        output_s(index_loc,2)=Lat
        output_s(index_loc,3)=Lon
        output_s(index_loc,4)=Press
        output_s(index_loc,5)=Temp
        output_s(index_loc,6)=H2O
        output_s(index_loc,7)=Cfactor
        output_s(index_loc,8)=JfactNO2
        output_s(index_loc,9)=JfactO1D
        output_s(index_loc,10)=RO2
        output_s(index_loc,11:) = C 
        !rate
        output_r(index_loc,1)=Jday*86400  + DAYCOUNTER*dt 
        output_r(index_loc,2)=Lat
        output_r(index_loc,3)=Lon
        output_r(index_loc,4)=Press
        output_r(index_loc,5)=Temp
        output_r(index_loc,6)=H2O
        output_r(index_loc,7:) = Rconst
 
        end subroutine SaveOut

      
        ! ****************************************************************


        SUBROUTINE ICNVRT(WAY,NUM,STRING,LENGTH,IERR)
        !
        !       FUNCTION:
        !F
        !F        This subroutine does an integer-to-character conversion
        !F        or a characater-to-integer conversion depending on the
        !F        integer WAY:
        !F                If WAY = 0 then an integer-to-character conversion
        !F                is done. If WAY .NE. 0 then a character-to-integer
        !F                conversion is done.
        !F
        !       USAGE:
        !U
        !U        !ALL I!NVRT(WAY,NUM,STRING)[
        !U             where WAY, NUM, STRING, and LENGTH are defined below.
        !U
        !U        Example: !ALL I!NVRT(0,1000,STRING,LENGTH)
        !U                 on return STRING = '1000' and
        !U                 LENGTH = 4.
        !U         
        !       INPUTS:
        !I
        !I        WAY - INTEGER; Determines which way the conversion goes:
        !I              if WAY = 0 then an integer-to-character conversion
        !I                         is performed;
        !I              if WAY.NE.0 then a character-to-integer conversion
        !I                         is performed.
        !I
        !I         NUM - INTEGER; an input only if WAY = 0. NUM is the integer
        !I               number to be converted to a character expression.
        !I
        !I         STRING - !HARACTER; an input only if WAY .NE. 0. STRING
        !I                is the character expression to be converted to an
        !CI                integer value. It contain no decimal points or 
        !I                non-numeric characters other than possibly a
        !I                sign. If STRING contains  a '+' sign, it will be
        !I                stripped of it on return.
        !I
        !       OUTPUTS:
        !O
        !O         NUM - INTEGER; contains the INTEGER representation of 
        !O                STRING.
        !O
        !O         STRING - !HARA!TER; contains the CHARACTER representation of
        !O                  NUM.
        !CO
        !CO         LENGTH - INTEGER; The length of STRING to the first blank.
        !CO                  The significant part of STRING can be accessed withJ(41)
        !CO                  the declaration STRING(1:LENGTH).
        !CO
        !CO         IERR - INTEGER variable giving return condition:
        !CO                IERR = 0 for normal return;
        !CO                IERR = 1 if NUM cannot be converted to STRING becauseJ(41)
        !CO                       STRING is too short or STRING cannot be
        !CO                       converted to NUM because STRING is too long.
        !CO                IERR = 2 if STRING contained a non-numeric character
        !CO                       other than a leading sign or something went
        !CO                       wrong with an integer-to-character conversion.J(41)
        !CO
        !C       ALGORITHM:
        !CA
        !CA         Nothing noteworthy, except that this subroutine will work
        !CA          for strange character sets where the character '1' doesn't
        !CA          follow '0', etc.
        !CA
        !C       MACHINE DEPENDENCIES:
        !CM
        !CM          The parameter MAXINT (below) should be set to the
        !CM          number of digits that an INTEGER data type can have
        !CM          not including leading signs. For VAX FORTRAN V4.4-177
        !CM          MAXINT = 10.
        !CM
        !CM          NOTE: Under VAX FORTRAN V4.4-177, the
        !CM          error condition IERR = 1 will never occur for an
        !CM          integer-to-character conversion if STRING
        !CM          is allocated at least 11 bytes (CHARACTER*11).
        !CM
        !C       HISTORY:
        !CH
        !CH      written by:             bobby bodenheimer
        !CH      date:                   september 1986
        !CH      current version:        1.0
        !CH      modifications:          none
        !CH
        !C       ROUTINES CALLED:
        !CC
        !CC          NONE.
        !CC
        !C----------------------------------------------------------------------J(41)
        !C       written for:    The CASCADE Project
        !C                       Oak Ridge National Laboratory
        !C                       U.S. Department of Energy
        !C                       contract number DE-AC05-840R21400
        !C                       subcontract number 37B-7685 S13
        !C                       organization:  The University of Tennessee
        !C----------------------------------------------------------------------J(41)
        !C       THIS SOFTWARE IS IN THE PUBLIC DOMAIN
        !C       NO RESTRICTIONS ON ITS USE ARE IMPLIED
        !C----------------------------------------------------------------------J(41)
        !C
        !C Global Variables.
        !C
        INTEGER       WAY
        INTEGER       LENGTH
        INTEGER       NUM
        INTEGER       IERR
        CHARACTER*(*) STRING
        !C    
        !C Local Variables
        !C
        INTEGER       I
        INTEGER       MAXINT
        INTEGER       MNUM
        INTEGER       M
        LOGICAL       NEG
        character(1) dummy
        integer    dummyvar
        !C
        PARAMETER(MAXINT=10)
        !C
        NEG = .FALSE.
        IERR = 0
        !C
        !C  Integer-to-character conversion.
        !C
        IF (WAY.EQ.0) THEN
        STRING = ' '
        IF (NUM.LT.0) THEN
        NEG = .TRUE.
        MNUM = -NUM
        LENGTH = INT(LOG10(REAL(MNUM))) + 1
        ELSE IF (NUM.EQ.0) THEN
        MNUM = NUM
        LENGTH = 1
        ELSE
        MNUM = NUM
        LENGTH = INT(LOG10(REAL(MNUM))) + 1
        END IF
        IF (LENGTH.GT.LEN(STRING)) THEN
        IERR = 1
        RETURN
        END IF


        DO 10, I=LENGTH,1,-1
        M=INT(REAL(MNUM)/10**(I-1))

        !jkhjkhjkhjkhljhlkjhj 
        if (m.lt.10) then 
        Write( dummy, '(i1)' ) M
        STRING(LENGTH-I+1:LENGTH-I+1) = dummy
        ELSE
        IERR = 2
        RETURN
        END IF


        MNUM = MNUM - M*10**(I-1)
        10       CONTINUE
        IF (NEG) THEN
        STRING = '-'//STRING
        LENGTH = LENGTH + 1
        END IF
        !C
        !C  Character-to-integer conversion.
        !!C
        ELSE
        IF (STRING(1:1).EQ.'-') THEN
        NEG = .TRUE.
        STRING = STRING(2:LEN(STRING))
        END IF
        IF (STRING(1:1).EQ.'+') STRING = STRING(2:LEN(STRING))
        NUM = 0
        LENGTH = INDEX(STRING,' ') - 1
        IF (LENGTH.GT.MAXINT) THEN
        IERR = 1
        RETURN
        END IF


        DO 20, I=LENGTH,1,-1           
        read( STRING(LENGTH-I+1:LENGTH-I+1), '(i10)' ) dummyvar
        if (dummyvar.lt.10) then 
        M= (dummyvar) 
        ELSE
        IERR = 2
        RETURN
        END IF

        NUM = NUM + INT(10**(I-1))*M
        20       CONTINUE

        IF (NEG) THEN
        NUM = -NUM
        STRING = '-'//STRING
        LENGTH = LENGTH + 1
        END IF
        END IF
        !C
        !C  Last lines of ICNVRT
        !C
        RETURN
        END SUBROUTINE
        


        
! End INLINED Utility Functions

! Utility Functions from KPP_HOME/util/util
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! UTIL - Utility functions
!   Arguments :
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

! ****************************************************************
!                            
! InitSaveData - Opens the data file for writing
!   Parameters :                                                  
!
! ****************************************************************

      SUBROUTINE InitSaveData ()

      USE model_Parameters

      open(10, file='model.dat')

      END SUBROUTINE InitSaveData

! End of InitSaveData function
! ****************************************************************

! ****************************************************************
!                            
! SaveData - Write LOOKAT species in the data file 
!   Parameters :                                                  
!
! ****************************************************************

      SUBROUTINE SaveData ()

      USE model_Global
      USE model_Monitor

      INTEGER i

      WRITE(10,999) (TIME-TSTART)/3600.D0,  &
                   (C(LOOKAT(i))/CFACTOR, i=1,NLOOKAT)
999   FORMAT(E24.16,100(1X,E24.16))

      END SUBROUTINE SaveData

! End of SaveData function
! ****************************************************************

! ****************************************************************
!                            
! CloseSaveData - Close the data file 
!   Parameters :                                                  
!
! ****************************************************************

      SUBROUTINE CloseSaveData ()

      USE model_Parameters

      CLOSE(10)

      END SUBROUTINE CloseSaveData

! End of CloseSaveData function
! ****************************************************************

! ****************************************************************
!                            
! GenerateMatlab - Generates MATLAB file to load the data file 
!   Parameters : 
!                It will have a character string to prefix each 
!                species name with.                                                 
!
! ****************************************************************

      SUBROUTINE GenerateMatlab ( PREFIX )

      USE model_Parameters
      USE model_Global
      USE model_Monitor

      
      CHARACTER(LEN=8) PREFIX 
      INTEGER i

      open(20, file='model.m')
      write(20,*) 'load model.dat;'
      write(20,990) PREFIX
990   FORMAT(A1,'c = model;')
      write(20,*) 'clear model;'
      write(20,991) PREFIX, PREFIX
991   FORMAT(A1,'t=',A1,'c(:,1);')
      write(20,992) PREFIX
992   FORMAT(A1,'c(:,1)=[];')

      do i=1,NLOOKAT
        write(20,993) PREFIX, SPC_NAMES(LOOKAT(i)), PREFIX, i
993     FORMAT(A1,A6,' = ',A1,'c(:,',I2,');')
      end do
      
      CLOSE(20)

      END SUBROUTINE GenerateMatlab

! End of GenerateMatlab function
! ****************************************************************


! ****************************************************************
!                            
! tag2num - convert equation tags to kpp reaction number
!   Arguments :
!      id        - string with the equation tag
!
! ****************************************************************

ELEMENTAL INTEGER FUNCTION tag2num ( id )

  USE model_Monitor, ONLY: EQN_TAGS

  CHARACTER(LEN=*), INTENT(IN) :: id
  INTEGER i

  tag2num = 0 ! mz_rs_20050115
  DO i = 1, SIZE(EQN_TAGS)
    IF (TRIM(EQN_TAGS(i)) == TRIM(id)) THEN
      tag2num = i ! mz_rs_20050115
      EXIT
    ENDIF
  END DO

END FUNCTION tag2num

! End of tag2num function
! ****************************************************************

! End Utility Functions from KPP_HOME/util/util
! End of UTIL function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! Shuffle_user2kpp - function to copy concentrations from USER to KPP
!   Arguments :
!      V_USER    - Concentration of variable species in USER's order
!      V         - Concentrations of variable species (local)
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SUBROUTINE Shuffle_user2kpp ( V_USER, V )

! V_USER - Concentration of variable species in USER's order
  REAL(kind=dp) :: V_USER(NVAR)
! V - Concentrations of variable species (local)
  REAL(kind=dp) :: V(NVAR)

  V(9) = V_USER(1)
  V(12) = V_USER(2)
  V(3) = V_USER(3)
  V(46) = V_USER(4)
  V(31) = V_USER(5)
  V(37) = V_USER(6)
  V(21) = V_USER(7)
  V(23) = V_USER(8)
  V(8) = V_USER(9)
  V(14) = V_USER(10)
  V(4) = V_USER(11)
  V(39) = V_USER(12)
  V(45) = V_USER(13)
  V(26) = V_USER(15)
  V(33) = V_USER(16)
  V(17) = V_USER(17)
  V(6) = V_USER(18)
  V(16) = V_USER(19)
  V(29) = V_USER(20)
  V(34) = V_USER(21)
  V(25) = V_USER(23)
  V(44) = V_USER(24)
  V(42) = V_USER(25)
  V(36) = V_USER(26)
  V(5) = V_USER(27)
  V(1) = V_USER(29)
  V(30) = V_USER(30)
  V(32) = V_USER(31)
  V(18) = V_USER(32)
  V(41) = V_USER(34)
  V(19) = V_USER(35)
  V(13) = V_USER(36)
  V(38) = V_USER(37)
  V(24) = V_USER(38)
  V(20) = V_USER(39)
  V(43) = V_USER(40)
  V(7) = V_USER(41)
  V(28) = V_USER(42)
  V(47) = V_USER(43)
  V(40) = V_USER(44)
  V(35) = V_USER(45)
  V(10) = V_USER(46)
      
END SUBROUTINE Shuffle_user2kpp

! End of Shuffle_user2kpp function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! Shuffle_kpp2user - function to restore concentrations from KPP to USER
!   Arguments :
!      V         - Concentrations of variable species (local)
!      V_USER    - Concentration of variable species in USER's order
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SUBROUTINE Shuffle_kpp2user ( V, V_USER )

! V - Concentrations of variable species (local)
  REAL(kind=dp) :: V(NVAR)
! V_USER - Concentration of variable species in USER's order
  REAL(kind=dp) :: V_USER(NVAR)

  V_USER(1) = V(9)
  V_USER(2) = V(12)
  V_USER(3) = V(3)
  V_USER(4) = V(46)
  V_USER(5) = V(31)
  V_USER(6) = V(37)
  V_USER(7) = V(21)
  V_USER(8) = V(23)
  V_USER(9) = V(8)
  V_USER(10) = V(14)
  V_USER(11) = V(4)
  V_USER(12) = V(39)
  V_USER(13) = V(45)
  V_USER(15) = V(26)
  V_USER(16) = V(33)
  V_USER(17) = V(17)
  V_USER(18) = V(6)
  V_USER(19) = V(16)
  V_USER(20) = V(29)
  V_USER(21) = V(34)
  V_USER(23) = V(25)
  V_USER(24) = V(44)
  V_USER(25) = V(42)
  V_USER(26) = V(36)
  V_USER(27) = V(5)
  V_USER(29) = V(1)
  V_USER(30) = V(30)
  V_USER(31) = V(32)
  V_USER(32) = V(18)
  V_USER(34) = V(41)
  V_USER(35) = V(19)
  V_USER(36) = V(13)
  V_USER(37) = V(38)
  V_USER(38) = V(24)
  V_USER(39) = V(20)
  V_USER(40) = V(43)
  V_USER(41) = V(7)
  V_USER(42) = V(28)
  V_USER(43) = V(47)
  V_USER(44) = V(40)
  V_USER(45) = V(35)
  V_USER(46) = V(10)
      
END SUBROUTINE Shuffle_kpp2user

! End of Shuffle_kpp2user function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! GetMass - compute total mass of selected atoms
!   Arguments :
!      CL        - Concentration of all species (local)
!      Mass      - value of mass balance
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SUBROUTINE GetMass ( CL, Mass )

! CL - Concentration of all species (local)
  REAL(kind=dp) :: CL(NSPEC)
! Mass - value of mass balance
  REAL(kind=dp) :: Mass(1)

      
END SUBROUTINE GetMass

! End of GetMass function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! ComputeFamilies - function to calculate user-defined Prod/Loss families
!   Arguments :
!      V         - Concentrations of variable species (local)
!      FAM       - Accumulated user-defined prod/loss families.
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SUBROUTINE ComputeFamilies ( V, FAM )

! V - Concentrations of variable species (local)
  REAL(kind=dp) :: V(NVAR)
! FAM - Accumulated user-defined prod/loss families.
  REAL(kind=dp) :: FAM(NFAM)


! Computation of prod/loss families
      
END SUBROUTINE ComputeFamilies

! End of ComputeFamilies function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



END MODULE model_Util

